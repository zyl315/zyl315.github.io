<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android学习之kotlin （四）</title>
    <url>/2021/03/16/Kotlin/Kotlin%E5%AD%A6%E4%B9%A0%E5%9B%9B/</url>
    <content><![CDATA[<h4 id="Kotlin高阶函数"><a href="#Kotlin高阶函数" class="headerlink" title="Kotlin高阶函数"></a>Kotlin高阶函数</h4><p>此Kotlin支持多种方式来调用高阶函数，比如另一个函数、Lambda表达式、匿名函数、成员引用等。其中，Lambda表达式是最常见也是最普遍的高阶函数调用方式</p>
<h5 id="1-定义高阶函数"><a href="#1-定义高阶函数" class="headerlink" title="1 定义高阶函数"></a>1 定义高阶函数</h5><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">minus</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> num1 - num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">num1AndNum2</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>, operation: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">	<span class="keyword">val</span> result = operation(num1, num2)</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">val</span> num1 = <span class="number">100</span></span><br><span class="line">	<span class="keyword">val</span> num2 = <span class="number">80</span></span><br><span class="line">	<span class="keyword">val</span> result1 = num1AndNum2(num1, num2, ::plus)</span><br><span class="line">	<span class="keyword">val</span> result2 = num1AndNum2(num1, num2, ::minus)</span><br><span class="line">	println(<span class="string">"result1 is <span class="variable">$result1</span>"</span>)</span><br><span class="line">	println(<span class="string">"result2 is <span class="variable">$result2</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里调用num1AndNum2()函数的方式，第三个参数使用了::plus和::minus这种写法。这是一种函数引用方式的写法，表示将plus()和minus()函数作为参数传递给num1AndNum2()函数。</p>
<p>上述代码如果使用Lambda表达式的写法来实现的话，代码如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">val</span> num1 = <span class="number">100</span></span><br><span class="line">	<span class="keyword">val</span> num2 = <span class="number">80</span></span><br><span class="line">	<span class="keyword">val</span> result1 = num1AndNum2(num1, num2) &#123; n1, n2 -&gt;</span><br><span class="line">		n1 + n2</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">val</span> result2 = num1AndNum2(num1, num2) &#123; n1, n2 -&gt;</span><br><span class="line">		n1 - n2</span><br><span class="line">	&#125;</span><br><span class="line">	println(<span class="string">"result1 is <span class="variable">$result1</span>"</span>)</span><br><span class="line">	println(<span class="string">"result2 is <span class="variable">$result2</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-内联函数"><a href="#2-内联函数" class="headerlink" title="2 内联函数"></a>2 内联函数</h5><p>内联函数的用法非常简单，只需要在定义高阶函数时加上inline关键字的声明即可，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">num1AndNum2</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>, operation: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">	<span class="keyword">val</span> result = operation(num1, num2)</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内联函数的工作原理是是Kotlin编译器会将内联函数中的代码在编译的时候自动替换到调用它的地方，这样也就不存在运行时的开销了。</p>
<h5 id="3-noinline与crossinline"><a href="#3-noinline与crossinline" class="headerlink" title="3 noinline与crossinline"></a>3 noinline与crossinline</h5><p>一个高阶函数中如果接收了两个或者更多函数类型的参数，这时我们给函数加上了inline关键字，那么Kotlin编译器会自动将所有引用的Lambda表达式全部进行内联。</p>
<p>只想内联其中的一个Lambda表达式,使用noinline关键字了，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">inlineTest</span><span class="params">(block1: () -&gt; <span class="type">Unit</span>, <span class="keyword">noinline</span> block2: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非内联的函数类型参数可以自由地传递给其他任何函数，因为它就是一个真实的参数，而内联的函数类型参数只允许传递给另外一个内联函数，这也是它最大的局限性。另外，内联函数和非内联函数还有一个重要的区别，那就是内联函数所引用的Lambda表达式中是可以使用return关键字来进行函数返回的，而非内联函数只能进行局部返回。</p>
<p>在高阶函数中创建了另外的Lambda或者匿名类的实现，并且在这些实现中调用函数类型参数，此时再将高阶函数声明成内联函数，就一定会提示错误。crossinline关键字就像一个契约，它用于保证在内联函数的Lambda表达式中一定不会使用return关键字。</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Android学习之kotlin （三）</title>
    <url>/2021/03/16/Kotlin/Kotlin%E5%AD%A6%E4%B9%A0%E4%B8%89/</url>
    <content><![CDATA[<h4 id="Kotlin扩展函数和运算符重载"><a href="#Kotlin扩展函数和运算符重载" class="headerlink" title="Kotlin扩展函数和运算符重载"></a>Kotlin扩展函数和运算符重载</h4><h5 id="1-扩展函数"><a href="#1-扩展函数" class="headerlink" title="1 扩展函数"></a>1 扩展函数</h5><p>扩展函数表示即使在不修改某个类的源码的情况下，仍然可以打开这个类，向该类添加新的函数。</p>
<p>定义扩展函数只需要在函数名的前面加上一个ClassName.的语法结构，就表示将该函数添加到指定类当中了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> ClassName.<span class="title">methodName</span><span class="params">(param1: <span class="type">Int</span>, param2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-运算符重载"><a href="#2-运算符重载" class="headerlink" title="2 运算符重载"></a>2 运算符重载</h5><p>符重载使用的是operator关键字，只要在指定函数的前面加上operator关键字，就可以实现运算符重载的功能了。</p>
<p>以加号运算符为例，如果想要实现让两个对象相加的功能，那么它的语法结构如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</span><br><span class="line">	<span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(obj: <span class="type">Obj</span>)</span></span>: Obj &#123;</span><br><span class="line">		<span class="comment">// 处理相加的逻辑 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现字符串的连乘， 定义为顶层函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">times</span><span class="params">(n : <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">	repeat(n) &#123;</span><br><span class="line">        builder.append(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"abc"</span> * <span class="number">3</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Android学习之kotlin （二）</title>
    <url>/2021/03/10/Kotlin/Kotlin%E5%AD%A6%E4%B9%A0%E4%BA%8C/</url>
    <content><![CDATA[<h3 id="Kotlin标准函数和静态方法"><a href="#Kotlin标准函数和静态方法" class="headerlink" title="Kotlin标准函数和静态方法"></a>Kotlin标准函数和静态方法</h3><h5 id="1-标准函数with、run和apply"><a href="#1-标准函数with、run和apply" class="headerlink" title="1 标准函数with、run和apply"></a>1 标准函数with、run和apply</h5><h6 id="with函数"><a href="#with函数" class="headerlink" title="with函数"></a><strong>with</strong>函数</h6><p>接收两个参数：第一个参数可以是一个任意类型的对象，第二个参数是一个Lambda表达式。with函数会在Lambda表达式中提供第一个参数对象的上下文，并使用Lambda表达式中的最后一行代码作为返回值返回</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> result = with(obj) &#123;</span><br><span class="line">	<span class="comment">// 这里是obj的上下文</span></span><br><span class="line">	<span class="string">"value"</span> <span class="comment">// with函数的返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="run函数"><a href="#run函数" class="headerlink" title="run函数"></a>run函数</h6><p>的用法和使用场景其实和with函数是非常类似的，只是稍微做了一些语法改动而已。首先run函数通常不会直接调用，而是要在某个对象的基础上调用；其次run函数只接收一个Lambda参数，并且会在Lambda表达式中提供调用对象的上下文。其他方面和with函数是一样的，包括也会使用Lambda表达式中的最后一行代码作为返回值返回</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> result = obj.run &#123;</span><br><span class="line">	<span class="comment">// 这里是obj的上下文</span></span><br><span class="line">	<span class="string">"value"</span> <span class="comment">// run函数的返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="apply函数"><a href="#apply函数" class="headerlink" title="apply函数"></a>apply函数</h6><p>和run函数也是极其类似的，都要在某个对象上调用，并且只接收一个Lambda参数，也会在Lambda表达式中提供调用对象的上下文，但是apply函数无法指定返回值，而是会自动返回调用对象本身</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> result = obj.apply &#123;</span><br><span class="line">	<span class="comment">// 这里是obj的上下文</span></span><br><span class="line">&#125; <span class="comment">// result == obj</span></span><br></pre></td></tr></table></figure>

<h5 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2 静态方法"></a>2 静态方法</h5><h6 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h6><p>静态方法在某些编程语言里面又叫作类方法，指的就是那种不需要创建实例就能调用的方法，所有主流的编程语言都会支持静态方法这个特性。为Kotlin提供了比静态方法更好用的语法特性——单例类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"do action"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kotlin</span></span><br><span class="line">object Util &#123;</span><br><span class="line">	<span class="function">fun <span class="title">doAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		println(<span class="string">"do action"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="伴随类"><a href="#伴随类" class="headerlink" title="伴随类"></a>伴随类</h6><p>希望让类中的某一个方法变成静态方法, 使用伴随对象</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">doAction1</span><span class="params">()</span></span> &#123;</span><br><span class="line">		println(<span class="string">"do action1"</span>)</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">		<span class="function"><span class="keyword">fun</span> <span class="title">doAction2</span><span class="params">()</span></span> &#123;</span><br><span class="line">			println(<span class="string">"do action2"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="注解和顶层方法"><a href="#注解和顶层方法" class="headerlink" title="注解和顶层方法"></a>注解和顶层方法</h6><p>确实需要定义真正的静态方法， Kotlin仍然提供了两种实现方式：注解和顶层方法。</p>
<p><strong>注解</strong></p>
<p>给单例类或companion object中的方法加上@JvmStatic注解，那么Kotlin编译器就会将这些方法编译成真正的静态方法</p>
<p><strong>顶层方法</strong></p>
<p>指那些没有定义在任何类中的方法，例如：<code>main()</code>方法。在Kotlin中所有的顶层方法都可以在任何位置被直接调用，不用管包名路径，也不用创建实例。在Java中使用文件名加方法调用。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Kt文件 Helper.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Kotlin中调用</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    doSomething()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Java调用</span></span><br><span class="line"><span class="keyword">public</span> static void main(String args[]) &#123;</span><br><span class="line">	HelperKt.doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Android学习之Activity</title>
    <url>/2021/03/10/android/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C(Activity)/</url>
    <content><![CDATA[<h5 id="1-Activity-的启动模式"><a href="#1-Activity-的启动模式" class="headerlink" title="1 Activity 的启动模式"></a>1 Activity 的启动模式</h5><p>启动模式一共有4种，分别是standard、singleTop、singleTask和singleInstance，可以在|AndroidManifest.xml中通过给<activity>标签指定，android: launchMode属性来选择启动模式</p>
<h6 id="1-1-standard"><a href="#1-1-standard" class="headerlink" title="1.1 standard"></a>1.1 standard</h6><p> Activity默认的启动模式，在不进行显式指定的情况下，所有Activity都会自动使用这种启动模式。</p>
<h6 id="1-2-singleTop"><a href="#1-2-singleTop" class="headerlink" title="1.2 singleTop"></a>1.2 singleTop</h6><p>在启动Activity时如果发现返回栈的栈顶已经是该Activity，则认为可以直接使用它，不会再创建新的Activity实例。不过当Activity并未处于栈顶位置时，再启动Activity还是会创建新的实例的。</p>
<h6 id="1-3-singleTask"><a href="#1-3-singleTask" class="headerlink" title="1.3 singleTask"></a>1.3 singleTask</h6><p>每次启动该Activity时，系统首先会在返回栈中检查是否存在该Activity的实例，如果发现已经存在则直接使用该实例，并把在这个Activity之上的所有其他Activity统统出栈，如果没有发现就会创建一个新的Activity实例。</p>
<h6 id="1-4-singleInstance"><a href="#1-4-singleInstance" class="headerlink" title="1.4 singleInstance"></a>1.4 singleInstance</h6><p>有一个单独的返回栈来管理这个Activity，不管是哪个应用程序来访问这个Activity，都共用同一个返回栈，也就解决了共享Activity实例的问题。（如果singleTask模式指定了不同的taskAffinity，也会启动一个新的返回栈）</p>
<h5 id="2-创建BaseActivity类"><a href="#2-创建BaseActivity类" class="headerlink" title="2 创建BaseActivity类"></a>2 创建BaseActivity类</h5><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">		Log.d(<span class="string">"BaseActivity"</span>, javaClass.simpleName)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其它类在继承BaseActivity类，可以在BaseActivity实现一些共有的方法。</p>
<h5 id="3-创建Activity管理工具"><a href="#3-创建Activity管理工具" class="headerlink" title="3 创建Activity管理工具"></a>3 创建Activity管理工具</h5><p>新建一个单例类ActivityCollector作为Activity的集合</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> ActivityCollector &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> activities = ArrayList&lt;Activity&gt;()    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addActivity</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        activities.add(activity)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">removeActivity</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        activities.remove(activity)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">finishAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (activity <span class="keyword">in</span> activities) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!activity.isFinishing) &#123;</span><br><span class="line">                activity.finish()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; activities . clear ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="4-优雅的启动Activity"><a href="#4-优雅的启动Activity" class="headerlink" title="4 优雅的启动Activity"></a>4 优雅的启动Activity</h6><p>使用Kotlin的伴随对象来传递Activity需要传递的参数，在companion object中的方法都可以使用类似于Java静态方法的形式调用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondActivity</span> : <span class="type">BaseActivity</span></span>() &#123;</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">		<span class="function"><span class="keyword">fun</span> <span class="title">actionStart</span><span class="params">(context: <span class="type">Context</span>, data1: <span class="type">String</span>, data2: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">val</span> intent = Intent(context, SecondActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">			intent.putExtra(<span class="string">"param1"</span>, data1)</span><br><span class="line">			intent.putExtra(<span class="string">"param2"</span>, data2)</span><br><span class="line">			context.startActivity(intent)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>activity, kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Android学习之kotlin （一）</title>
    <url>/2021/03/04/Kotlin/Kotlin%E5%AD%A6%E4%B9%A0%E4%B8%80/</url>
    <content><![CDATA[<h4 id="Kotlin基本"><a href="#Kotlin基本" class="headerlink" title="Kotlin基本"></a>Kotlin基本</h4><h5 id="1、继承与构造函数"><a href="#1、继承与构造函数" class="headerlink" title="1、继承与构造函数"></a>1、继承与构造函数</h5><p>Kotlin中默认类不可以被继承，使用<code>open</code>关键字之后才可以被继承。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类继承父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Studen</span> : <span class="type">Person</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Kotlin将构造函数分成了两种：主构造函数和次构造函数。</p>
<p>Kotlin规定，当一个类既有主构造函数又有次构造函数时，所有的次构造函数都必须调用主构造函数（包括间接调用）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name:String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带参数的主构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>, name, age) : Person(name, age) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 次构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>, name, age) : Person(name, age) &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name:String, age:<span class="built_in">Int</span>) : <span class="keyword">this</span>(<span class="string">""</span>,<span class="number">0</span>, name, age)<span class="comment">//this关键字调用了主构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、接口"><a href="#2、接口" class="headerlink" title="2、接口"></a>2、接口</h5><p>Kotlin中的接口与java类似，Kotlin允许对接口中定义的函数进行默认实现（Java 8后开始支持。</p>
<h5 id="3、数据类与单例类"><a href="#3、数据类与单例类" class="headerlink" title="3、数据类与单例类"></a>3、数据类与单例类</h5><p>数据类关键字<code>data</code>，Kotlin将Java中<code>equals()、hashCode()、toString()</code>等固定且无实际逻辑意义的方法自动生成。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>单例类，使用关键字<code>object</code>即可。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Lambda基本"><a href="#Lambda基本" class="headerlink" title="Lambda基本"></a>Lambda基本</h4><h5 id="1-List-Set-Map的构建"><a href="#1-List-Set-Map的构建" class="headerlink" title="1  List, Set, Map的构建"></a>1  List, Set, Map的构建</h5><p>Kotlin可以采取Java的方式创建，也可以使用函数来创建</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list = ArrayList&lt;String&gt;()</span><br><span class="line">list.add(<span class="string">"Apple"</span>)</span><br><span class="line">list.add(<span class="string">"Banana"</span>)</span><br><span class="line">list.add(<span class="string">"Orange"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态列表创建</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"pear"</span>)</span><br><span class="line"><span class="comment">// 动态列表创建</span></span><br><span class="line"><span class="keyword">val</span> list = mutableListOf(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"pear"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态集合创建</span></span><br><span class="line"><span class="keyword">val</span> list = setOf(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"pear"</span>)</span><br><span class="line"><span class="comment">// 动态集合创建</span></span><br><span class="line"><span class="keyword">val</span> list = mutableSetOf(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"pear"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态Map创建</span></span><br><span class="line"><span class="keyword">val</span> list = mapOf(<span class="string">"apple"</span> to <span class="number">1</span>, <span class="string">"banana"</span> to <span class="number">2</span>, <span class="string">"pear"</span> to <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 动态Map创建</span></span><br><span class="line"><span class="keyword">val</span> list = mutableMapOf(<span class="string">"apple"</span> to <span class="number">1</span>, <span class="string">"banana"</span> to <span class="number">2</span>, <span class="string">"pear"</span> to <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h5 id="2-集合的函数式API"><a href="#2-集合的函数式API" class="headerlink" title="2  集合的函数式API"></a>2  集合的函数式API</h5><p>Lambda表达式的语法结构：{参数名1: 参数类型, 参数名2: 参数类型 -&gt; 函数体}</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 水果集合里面找到单词最长的那个水果</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Pear"</span>, <span class="string">"Grape"</span>, <span class="string">"Watermelon"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> maxLengthFruit = list.maxBy(&#123; fruit: String -&gt; fruit.length &#125;)</span><br><span class="line"><span class="comment">// 当Lambda参数是函数的最后一个参数时，可以将Lambda表达式移到函数括号的外面</span></span><br><span class="line"><span class="keyword">val</span> maxLengthFruit = list.maxBy() &#123; fruit: String -&gt; fruit.length &#125;</span><br><span class="line"><span class="comment">// 如果Lambda参数是函数的唯一一个参数的话，还可以将函数的括号省略：</span></span><br><span class="line"><span class="keyword">val</span> maxLengthFruit = list.maxBy &#123; it.length &#125;</span><br></pre></td></tr></table></figure>

<p><code>list</code>还有更多函数式API，例如<code>.filter .map .any .all</code></p>
<h5 id="3-Java函数式API的使用"><a href="#3-Java函数式API的使用" class="headerlink" title="3 Java函数式API的使用"></a>3 Java函数式API的使用</h5><p>以android中的button为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// java Lambda</span></span><br><span class="line">button.setOnClickListener(view-&gt;&#123;&#125;);</span><br><span class="line"><span class="comment">//kotlin Lambda</span></span><br><span class="line">button.setOnClickListener &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-空指针检查"><a href="#4-空指针检查" class="headerlink" title="4 空指针检查"></a>4 空指针检查</h5><p>Kotlin默认所有的参数和变量都不可为空，可以声明为空，在类名的后面加上？<code>Int? String?</code> 然后要把空指针异常都处理掉。</p>
<p>判空辅助工具 <code>？.</code> 和<code>?:</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a != <span class="literal">null</span>) &#123;a.doSomething()&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">a?.doSometing()</span><br><span class="line"><span class="keyword">val</span> c = <span class="keyword">if</span> (a ! = <span class="literal">null</span>) &#123; a &#125; <span class="keyword">else</span> &#123; b &#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">val</span> c = a ?: b</span><br></pre></td></tr></table></figure>

<p><code>let</code>函数，let函数属于Kotlin中的标准函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">obj.let &#123; obj2 -&gt; obj2.doSomething() &#125;</span><br><span class="line"><span class="comment">// Lambda </span></span><br><span class="line">obj.let &#123; it.doSometing() &#125;</span><br><span class="line"><span class="comment">// obj判null</span></span><br><span class="line">obj?.let &#123; it.doSomething() &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Kotlin中的实用小技巧"><a href="#Kotlin中的实用小技巧" class="headerlink" title="Kotlin中的实用小技巧"></a>Kotlin中的实用小技巧</h4><h5 id="字符串内嵌表达式"><a href="#字符串内嵌表达式" class="headerlink" title="字符串内嵌表达式"></a>字符串内嵌表达式</h5><p>与JavaScript中类似</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="string">"hello, <span class="subst">$&#123;obj.name&#125;</span>. kotlin!"</span></span><br><span class="line"><span class="comment">// 表达式中仅有一个变量的时候，还可以将两边的大括号省略</span></span><br><span class="line"><span class="string">"hello, <span class="variable">$name</span>. kotlin"</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>kotlin, Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>$.ajax 报400错误</title>
    <url>/2021/01/05/ajax%E6%8A%A5400%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h1 id="ajax-报400错误"><a href="#ajax-报400错误" class="headerlink" title="$.ajax 报400错误"></a>$.ajax 报400错误</h1><p>今天在实际的项目中将jQuery的$.ajax请求方式由get改为post，发现报400错误；原因是由于contentType设置错误</p>
<h6 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contentType: &quot;application&#x2F;json;charset&#x3D;utf-8&quot;</span><br></pre></td></tr></table></figure>

<h6 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contentType: &quot;application&#x2F;x-www-form-urlencoded;charset&#x3D;UTF-8&quot;</span><br></pre></td></tr></table></figure>

<p>默认不设置也没问题</p>
<h6 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h6><p>java后端<code>@RequestMapping</code>的<code>Method</code>保持默认设置即可，可接受<code>GET、POST、PUT、DELETE</code>等请求。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>RxAndroid学习</title>
    <url>/2020/10/31/android/RxAndroid/</url>
    <content><![CDATA[<h3 id="RxAndroid-入门学习"><a href="#RxAndroid-入门学习" class="headerlink" title="RxAndroid 入门学习"></a>RxAndroid 入门学习</h3><blockquote>
<p>参考<a href="https://www.jianshu.com/p/5d761e283f24" target="_blank" rel="noopener">RxAndroid入门</a></p>
</blockquote>
<h4 id="1、响应式编程"><a href="#1、响应式编程" class="headerlink" title="1、响应式编程"></a>1、响应式编程</h4><p>具体的在上面的参考文献中说的已经非常清楚了，个人理解就是化繁为简，将多层次的嵌套变成流水式，是的代码更加清晰易读。</p>
<h4 id="2、Android怎么用"><a href="#2、Android怎么用" class="headerlink" title="2、Android怎么用"></a>2、Android怎么用</h4><p>使用RxAndroid添加如下依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url &quot;https:&#x2F;&#x2F;oss.jfrog.org&#x2F;libs-snapshot&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#39;io.reactivex.rxjava3:rxandroid:3.0.0&#39;</span><br><span class="line">    implementation &#39;io.reactivex.rxjava3:rxjava:3.0.0&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最新的依赖以及源码可以访问RxAndroid GitHub<a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="noopener">主页</a></p>
</blockquote>
<h5 id="Observable和Observe"><a href="#Observable和Observe" class="headerlink" title="Observable和Observe"></a>Observable和Observe</h5><p>非常典型的观察者模式：</p>
<p>​    Observable：被观察者，用来处理事件的派发；</p>
<p>​    Observe：观察者，关注Observable，当被Observable发生变化时，Observe可以迅速的做出响应，处理事务，Observable可以对应多个Observe。</p>
<p>具体代码可以参考开头。</p>
<p><code>Observable</code>相关的对象和方法：</p>
<ol>
<li><p>使用<code>Observable.create</code>创建<code>Observable</code>对象。</p>
</li>
<li><p><code>ObservableEmitter</code>为发射器，<code>Observable</code>使用它发射事件给所有<code>Observer</code>。</p>
</li>
<li><p>使用<code>Observable.subscribe</code>添加一个<code>Observer</code>。</p>
</li>
</ol>
<p><code>Observer</code>的几个方法：</p>
<ol>
<li>onSubscribe：在订阅<code>observable</code>时回调，可以在这里调用<code>Disposable.dispose</code>取消订阅或者将<code>Disposable</code>对象保存起来以便在后续某个时刻取消订阅。</li>
<li>onNext：在<code>ObservableEmitter.onNext</code>执行后回调，<code>onNext</code>表示的是整个响应链中的一环，在这里处理响应链中的其中一个任务，可以多次调用。</li>
<li>onComplete：在<code>ObservableEmitter.onComplete</code>执行后回调，表示任务已全部完成，可以在这里做收尾工作。</li>
<li>onError：在<code>ObservableEmitter.onError</code>执行后或者链中任一环节出现异常时回调，表示任务执行失败。</li>
</ol>
<p>特别的是Observable订阅Observe，即被观察者订阅观察者。</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>RxAndroid</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title>Android学习笔记-字符串的加解密</title>
    <url>/2020/10/18/android/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
    <content><![CDATA[<center>Android学习笔记（一）</center>
#### 要点

<p>1、在存储密钥时，要在Android环境下调试，不然下面的代码会报<code>Not found &#39;AndroidKeyStore&#39;</code>,根本原因是在PC java环境下与Android下load的方式不同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">KeyStore keyStore = KeyStore.getInstance(alias);</span><br><span class="line">keyStore.load(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>2、如果要设置自己的初始向量IV，关闭自动生成随机初始向量IV，需要设置以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setRandomizedEncryptionRequired(<span class="keyword">false</span>)</span><br></pre></td></tr></table></figure>

<p>自定义初始向量IV长度为12byte，即<code>iv = byte[12]</code></p>
<p>3、在byte[] 与String不能够等价的转换，即装换是不可逆的，将一个byte数组转换为String后再转换为byte[]，两者等价了。因此在加密的时候使用了Base64来做转码功能。</p>
<p>4、IV只支持<code>GCMParameterSpec iv = new GCMParameterSpec(128, sIv.getBytes(&quot;UTF-8&quot;));</code>生成的初始向量，使用别的会报错。</p>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyl315.acfun.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Build;</span><br><span class="line"><span class="keyword">import</span> android.security.keystore.KeyGenParameterSpec;</span><br><span class="line"><span class="keyword">import</span> android.security.keystore.KeyProperties;</span><br><span class="line"><span class="keyword">import</span> android.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.KeyStore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.GCMParameterSpec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.annotation.RequiresApi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncryptTool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String alias = <span class="string">"AndroidKeyStore"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String sIv = <span class="string">"qwertyuiopas"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequiresApi</span>(api = Build.VERSION_CODES.M)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//初始化一个使用AES加密的密钥生成器</span></span><br><span class="line">            <span class="keyword">final</span> KeyGenerator keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES);</span><br><span class="line">            <span class="comment">//配置参数</span></span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//这里生成密钥的参数中设置了alias，生成密钥的时候会自动将这个密钥保存在KeyStore中</span></span><br><span class="line">                <span class="keyword">final</span> KeyGenParameterSpec keyGenParameterSpec =</span><br><span class="line">                        <span class="keyword">new</span> KeyGenParameterSpec.Builder(alias, KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)</span><br><span class="line">                                .setBlockModes(KeyProperties.BLOCK_MODE_GCM)</span><br><span class="line">                                .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)</span><br><span class="line">                                .setRandomizedEncryptionRequired(<span class="keyword">false</span>)<span class="comment">//自己设置初始向量IV</span></span><br><span class="line">                                .build();</span><br><span class="line">                <span class="comment">//用参数初始化密钥生成器</span></span><br><span class="line">                keyGenerator.init(keyGenParameterSpec);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//用密钥生成器产生密钥</span></span><br><span class="line">            <span class="keyword">final</span> SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">            <span class="comment">//算法/模式/补码方式</span></span><br><span class="line">            <span class="keyword">final</span> Cipher cipher = Cipher.getInstance(<span class="string">"AES/GCM/NoPadding"</span>);</span><br><span class="line">            <span class="comment">//手动设置Initialization vector (IV)，解密需要这个iv</span></span><br><span class="line">            GCMParameterSpec iv = <span class="keyword">new</span> GCMParameterSpec(<span class="number">128</span>, sIv.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, secretKey, iv);</span><br><span class="line">            <span class="keyword">byte</span>[] encryption = cipher.doFinal(password.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            <span class="comment">//加密完成，此处使用BASE64做转码功能，同时能起到2次加密的作用</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(Base64.encode(encryption, Base64.DEFAULT),<span class="string">"UTF-8"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresApi</span>(api = Build.VERSION_CODES.M)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String encryption)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//使用Base64转码</span></span><br><span class="line">            <span class="keyword">byte</span>[] data = Base64.decode(encryption, Base64.DEFAULT);</span><br><span class="line">            <span class="comment">//获得keyStore</span></span><br><span class="line">            KeyStore keyStore = KeyStore.getInstance(alias);</span><br><span class="line">            keyStore.load(<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//从keystore中获取密钥Entry</span></span><br><span class="line">            <span class="keyword">final</span> KeyStore.SecretKeyEntry secretKeyEntry = (KeyStore.SecretKeyEntry) keyStore.getEntry(alias, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//从entry中获取AES密钥</span></span><br><span class="line">            <span class="keyword">final</span> SecretKey secretKey = secretKeyEntry.getSecretKey();</span><br><span class="line">            <span class="keyword">final</span> Cipher cipher = Cipher.getInstance(<span class="string">"AES/GCM/NoPadding"</span>);</span><br><span class="line">            <span class="keyword">final</span> GCMParameterSpec spec = <span class="keyword">new</span> GCMParameterSpec(<span class="number">128</span>, sIv.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, secretKey, spec);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">byte</span>[] decodedData = cipher.doFinal(data);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(decodedData, <span class="string">"UTF-8"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>附一张AC新的登录页面背景图，<img src= "/img/loading.gif" data-lazy-src="https://static.yximgs.com/udata/pkg/acfun/loginbg.be7a2d2876ab48ed.png" alt=""></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>AES</tag>
        <tag>keyStore</tag>
        <tag>Cipher</tag>
      </tags>
  </entry>
  <entry>
    <title>AcFun Banner一览</title>
    <url>/2020/10/04/AcFun%20Banner/</url>
    <content><![CDATA[<p><a href="https://www.acfun.cn/a/ac1881444" target="_blank" rel="noopener">AcFun Banner</a></p>
<p><a href="https://www.acfun.cn/a/ac15574934" target="_blank" rel="noopener">AcFun 13周年壁纸</a></p>
]]></content>
      <categories>
        <category>AcFun</category>
      </categories>
      <tags>
        <tag>AC</tag>
        <tag>banner</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3选择器</title>
    <url>/2020/10/04/CSS%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<h6 id="1-CSS3新增加的选择器："><a href="#1-CSS3新增加的选择器：" class="headerlink" title="1.CSS3新增加的选择器："></a>1.CSS3新增加的选择器：</h6><p>参考<a href="https://blog.csdn.net/w1418899532/article/details/89434136" target="_blank" rel="noopener">tomorrownan的博客</a>:css3新增选择器。</p>
<h6 id="2-动态伪类选择器"><a href="#2-动态伪类选择器" class="headerlink" title="2.动态伪类选择器"></a>2.动态伪类选择器</h6><p>锚点伪类：<code>:link</code>，<code>:visited</code></p>
<p>用户行为伪类：<code>:hover</code>,<code>active</code>,<code>:focus</code></p>
<h6 id="3-属性选择器"><a href="#3-属性选择器" class="headerlink" title="3.属性选择器"></a>3.属性选择器</h6><table>
<thead>
<tr>
<th align="center">选择器</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">E[attribute]</td>
<td>选取带有指定属性的元素</td>
</tr>
<tr>
<td align="center">E[attribute=value]</td>
<td>选取带有指定属性和值的元素</td>
</tr>
<tr>
<td align="center">E[attr^=“val”]</td>
<td>匹配属性attr的值以指定值”val”开头的每个元素</td>
</tr>
<tr>
<td align="center">E[attr$=“val”]</td>
<td>匹配属性attr的值以指定值”val”结尾的元素</td>
</tr>
<tr>
<td align="center">E[attr*=“val”]</td>
<td>匹配属性attr的值包含字符串”val”元素</td>
</tr>
</tbody></table>
<h6 id="3-UI元素状态伪类"><a href="#3-UI元素状态伪类" class="headerlink" title="3.UI元素状态伪类"></a>3.UI元素状态伪类</h6><p><code>:enabled</code>,<code>:disabled</code>,<code>:checked</code>.</p>
<h6 id="4-结构伪类选择器"><a href="#4-结构伪类选择器" class="headerlink" title="4.结构伪类选择器"></a>4.结构伪类选择器</h6><p><code>Elemnet:nth-child(n)</code>等，其中n必须从1开始，odd表示奇数，even表示偶数。</p>
<table>
<thead>
<tr>
<th>选择</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>:root</td>
<td>选择匹配文档的根元素</td>
</tr>
<tr>
<td>E:nth-child(n)</td>
<td>选择所有在其父元素中的<strong>第n个</strong>位置的匹配E的子元素</td>
</tr>
<tr>
<td>E:nth-last-child(n)</td>
<td>选择所有在其父元素中<strong>倒数第n个</strong>位置的匹配E的子元素</td>
</tr>
<tr>
<td>E:nth-of-type(n)</td>
<td>选择所有在其父元素中<strong>同类型第n个</strong>位置的匹配E的子元素</td>
</tr>
<tr>
<td>E:nth-last-of-type(n)</td>
<td>选择所有在其父元素中<strong>同类型倒数第n个</strong>位置的匹配E的子元素</td>
</tr>
<tr>
<td>E:last-child</td>
<td>选择位于其父元素中最后一个位置，且匹配E的子元素 ，与E:nth-last-child(1)等同</td>
</tr>
<tr>
<td>E:fisrt-child</td>
<td>选择位于其父元素中第一个位置，且匹配E的子元素 ，与E:nth-child(1)等同</td>
</tr>
<tr>
<td>E:first-of-type</td>
<td>选择在其父元素中匹配E的第一个同类型子元素</td>
</tr>
<tr>
<td>E:last-of-type</td>
<td>选择在其父元素中匹配E的最后一个同类型子元素</td>
</tr>
<tr>
<td>E:only-child</td>
<td>选择在其父元素中只包含一个子元素，且该子元素匹配E。</td>
</tr>
<tr>
<td>E:only-of-type</td>
<td>选择在其父元素中只包含一个同类型子元素，且该子元素匹配E。</td>
</tr>
<tr>
<td>E:empty</td>
<td>选择匹配E的元素，且该元素不包含子元素。</td>
</tr>
</tbody></table>
<h6 id="5-否定选择器"><a href="#5-否定选择器" class="headerlink" title="5.否定选择器"></a>5.否定选择器</h6><p><code>:not(Element/selector)</code>,选择器匹配非指定元素/选择器的每个元素。</p>
<h6 id="6-伪元素"><a href="#6-伪元素" class="headerlink" title="6 伪元素"></a>6 伪元素</h6><p><code>::frist-line</code> 对Element元素中的<font color='red'>第一行文本</font>进行格式化，只能作用于块级元素。</p>
<p><code>::frist-letter</code> 对Element元素中的<font color='red'>第一个字符</font>进行格式化，只能作用于块级元素。</p>
<p><code>::before</code>  在元素的内容前面插入新的内容。</p>
<p><code>::after</code> 在元素的内容后面插入新的内容。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3选择器</tag>
      </tags>
  </entry>
  <entry>
    <title>Git的知识点</title>
    <url>/2020/09/26/Git%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>可以查看张雪峰关于git的介绍，<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">地址</a></p>
<h5 id="1-创建git版本库"><a href="#1-创建git版本库" class="headerlink" title="1. 创建git版本库"></a>1. 创建git版本库</h5><p><code>git init</code>   把当前目录变成git可以管理的仓库。</p>
<p><code>git add 1.txt</code>把1.txt这个文件添加到git仓库，一定要在仓库所在的目录下哟！</p>
<p><code>git commit -m &quot;add a file&quot;</code>  把文件提交到仓库，-m 后面输入的是本次提交的说明，可以添加多个后一次性提交。 </p>
<h5 id="2-版本控制"><a href="#2-版本控制" class="headerlink" title="2. 版本控制"></a>2. 版本控制</h5><p><code>git log</code> 查看最近的提交历史的操作记录，由最近到最远排序， 添加<code>--pretty=oneline</code>可以简化查询信息。</p>
<p><code>git reset --hard HEAD^</code>  回退到上一个版本，<code>HEAD</code>是一个指针，指向当前版本，<code>HEAD^</code>表示上一个版本，<code>HEAD^^</code>表示上上个版本， <code>HEAD~100</code>表示上100个版本，可以确定要回退的版本。</p>
<p><code>git reflog</code> 查看操作命令历史，然后使用<code>git reset --hard commit_id</code>回到未来的版本。</p>
<p><code>git status</code> 可以查看当前工作区与暂存区文件提交的状态。</p>
<h5 id="3-工作区与缓存区"><a href="#3-工作区与缓存区" class="headerlink" title="3.工作区与缓存区"></a>3.工作区与缓存区</h5><p><img src= "/img/loading.gif" data-lazy-src="https://www.liaoxuefeng.com/files/attachments/919020037470528/0" alt="img"></p>
<p>使用<code>git add</code>实际上是把文件从工作区添加到暂存区；</p>
<p>使用<code>git commit</code>提交更改，实际上是把暂存区的内容提交到<code>master</code>分支，当我们在创建git版本仓库时，会自动创建一个唯一的<code>master</code>分支。</p>
<p>在每一次对工作区的文件进行修改后，先<code>git add</code>添加到缓存区，然后在<code>git commit</code> 提交到分支，这样才能实现对版本库里的文件进行更新。</p>
<h5 id="4-仓库文件管理"><a href="#4-仓库文件管理" class="headerlink" title="4.仓库文件管理"></a>4.仓库文件管理</h5><h6 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h6><blockquote>
<p><code>git diff Head -- file</code>当前工作区的与版本库里文件的差别。</p>
</blockquote>
<h6 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h6><blockquote>
<p><code>git checkout -- file</code>可以丢弃工作区的修改，即让这个文件回到<code>git commit</code>或者&gt;<code>git add</code>时的状态，<strong>注意，其中的<code>--</code>十分重要，如果去掉就是切换分支的命令了</strong>。</p>
<p>如果文件已经提交到了暂存区<code>git add</code>，想丢弃修改，首先使用<code>git reset Head &gt;&lt;file&gt;</code>命令，然后再使用<code>git checkour -- file</code>。</p>
<p>如果文件已经提交到了版本库里，要撤销本次提交，可以使用版本回退。</p>
</blockquote>
<h6 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h6><blockquote>
<p>可以使用Linux命令<code>rm file</code>或者直接在文件管理器中直接把文件删除了，也可以使用命令<code>git rm file</code>.</p>
</blockquote>
<h5 id="5-远程仓库"><a href="#5-远程仓库" class="headerlink" title="5.远程仓库"></a>5.远程仓库</h5><h6 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h6><blockquote>
<p><code>git remote add origin &gt;git@github.com:username/***.git</code>关联远程仓库,其中username是自己的github用户名，***为仓库名，可以在GitHub上等代码托管网站自己建立远程仓库。</p>
<p><code>git push -u origin master</code>第一次推送master分支的所有内容。</p>
<p><code>git push origin master</code> 第一次提交后，推送新的修改版本。</p>
<p>其中需要注意SSH有关方面的配置。</p>
</blockquote>
<p>克隆远程仓库</p>
<blockquote>
<p><code>git clone</code>,使用克隆命令，后面可以接仓库的https或SSH地址，例如：<code>git clone git@github.com:username/***.git</code>。</p>
</blockquote>
<h5 id="6-分支管理"><a href="#6-分支管理" class="headerlink" title="6.分支管理"></a>6.分支管理</h5><h6 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h6><blockquote>
<p><code>git branch</code>，查看当前分支。</p>
<p><code>git checkoout -b &lt;name&gt;</code>，表示创建分支并切换。</p>
<p>可以等价为两条语句:<code>git branch &lt;name&gt;</code>和<code>git checkout &lt;name&gt;</code>。</p>
<p><code>git checkout &lt;name&gt;</code> ，用来切换分支，但容易与<code>git chechout -- &lt;file&gt;</code>撤销修改命令混淆，最新版的Git可也以使用新的切换分支命令：</p>
<p><code>git switch &lt;name&gt;</code>来切换分支，但Git版本须2.23版本以上，可以使用<code>git update-git-for-windows</code>来更新,速度太慢不推荐。</p>
<p><code>git merge &lt;name&gt;</code>，用于合并指定分支到当前分支。</p>
<p><code>git branch -d &lt;name&gt;</code>, 删除分支。</p>
</blockquote>
<h6 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h6><blockquote>
<p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p>
<p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p>
<p><code>git log --graph</code>命令可以看到分支合并图。</p>
</blockquote>
<h6 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h6><blockquote>
<p>在分支合并时，大对数情况下采用的是<code>Fast forward</code>模式，在这种模式下，分支删除后就会丢失分支信息，可以采用</p>
<p><code>git merge --no--ff -m &quot;message&quot; &lt;name&gt;</code>, 这种方式会提交一个commit，合并后就会有历史分支，能看出来曾经做过的合并。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://www.liaoxuefeng.com/files/attachments/919023260793600/0" alt="img"></p>
<p>在实际开发过程中，master分支非常稳定，一般仅用来发布新版本，团队成员的开发一般会推送到dev分支等。</p>
</blockquote>
<h6 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h6><blockquote>
<p>Bug分支，顾名思义为了修复Bug而创建的分支，而当目前的工作还未还未完成，不能提交现在正在工作的分支，可以使用Git的<code>git stash</code>功能，可以把当前的工作现场“保存”下来，等到恢复现场后继续工作。</p>
<p><code>git stash lsit</code> 查看工作现场，恢复工作现场的办法有两个：</p>
<p><code>git stash apply</code> 恢复现场但不删除stash内容，<code>git stash drop</code>来删除stash中的内容。</p>
<p><code>git stash pop</code>可以回到工作现场，恢复的同时把stash内容删除。</p>
<p>当个多个分支上存在bug时，可以使用命令<code>git cherry-pick &lt;commit_id&gt;</code>，把bug提交到修改“复制”</p>
<p>到当前分支，避免重复劳动。</p>
</blockquote>
<h6 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h6><blockquote>
<p>开发一个新的功能，最好是新建一个分支，如果丢弃一个没有被合并的分支，可以使用命令</p>
<p><code>git branch -d &lt;name&gt;</code>强行删除。</p>
</blockquote>
<h6 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h6><blockquote>
<p>从远程仓库克隆时，实际上是对应本地master分支与远程仓库的master分支，远程仓库的默认名是origin。</p>
<p><code>git remote</code>，查看远程仓库信息。<br>推送分支:<br><code>git push origin &lt;branch_name&gt;</code>，在推送中可能出现失败，本地提交有冲突，先使用<code>git pull</code>从远程仓库拉取最新的提交，然后在本地解决冲突，再推送。</p>
</blockquote>
<h6 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h6><blockquote>
<p><code>git rebase</code>可以把本地未push的分叉提交历史整理成直线，可以使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p>
</blockquote>
<h5 id="7-标签管理"><a href="#7-标签管理" class="headerlink" title="7.标签管理"></a>7.标签管理</h5><p>标签可以使得查找commit更加容易，不在需要记得commit id，tag与某个commit绑定。</p>
<p><code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</p>
<p><code>git tag -a &lt;tagname&gt; -m &quot;***&quot;</code>可以指定标签信息；</p>
<p><code>git tag</code>可以查看所有标签。</p>
]]></content>
      <categories>
        <category>版本控制工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>跳转测试</title>
    <url>/2020/09/26/%E5%86%85%E9%83%A8%E7%BD%91%E9%A1%B5%E8%B7%B3%E8%BD%AC%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p><a href="/demo/mobile">慕课手机</a></p>
<p><a href="/demo/live2d">live2D</a></p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
  <entry>
    <title>WebAPP</title>
    <url>/2020/09/14/WebAPP/</url>
    <content><![CDATA[<h2 id="Web-App-开发相关知识"><a href="#Web-App-开发相关知识" class="headerlink" title="Web App 开发相关知识"></a>Web App 开发相关知识</h2><h4 id="物理像素与CSS像素"><a href="#物理像素与CSS像素" class="headerlink" title="物理像素与CSS像素"></a>物理像素与CSS像素</h4><blockquote>
<p>物理像素(physical pixel ),也可叫做设备像素(dp : device pixel)，与设备的物理特性相关，例如屏幕的分辨率，屏幕大小有关。</p>
</blockquote>
<blockquote>
<p>CSS像素，也可以叫做逻辑像素(logic pixel)，或者设备独立像素(device independent pixel)，实际开发中使用的就是CSS像素。</p>
</blockquote>
<blockquote>
<p>设备像素比(dpr : device pixel ratio), dpr=设备像素/CSS 像素（缩放比是1的情况下）。dpr=1为标清屏，dpr&gt;=2为高清屏。缩放是改变CSS像素。</p>
</blockquote>
<blockquote>
<p>PPI(pixels per inch), 每英寸的物理像素点i，也可以叫做dpi (dots per inch)。</p>
</blockquote>
<h4 id="viewport常用写法"><a href="#viewport常用写法" class="headerlink" title="viewport常用写法"></a>viewport常用写法</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1, minimum-scale=1"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中<code>width=device-width</code>与<code>initial-scale=1</code>实现的效果相同，是的网页在移动端可以正常显示大小，<code>user-scalable=no</code>与<code>maximum-scale=1,mimimum-scale=1</code>使得用户不能够缩放网页，以免影响布局效果。</p>
]]></content>
      <categories>
        <category>WebApp</category>
      </categories>
      <tags>
        <tag>pixel</tag>
        <tag>viewport</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3 动画</title>
    <url>/2020/08/11/CSS-animate/</url>
    <content><![CDATA[<h5 id="1-transform"><a href="#1-transform" class="headerlink" title="1 transform"></a>1 transform</h5><p><a href="https://www.w3school.com.cn/cssref/pr_transform.asp" target="_blank" rel="noopener">transform</a> 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜<br>例如：旋转 div 元素：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">transform:rotate(7deg);</span><br><span class="line">-ms-transform:rotate(7deg); 	/* IE 9 */</span><br><span class="line">-moz-transform:rotate(7deg); 	/* Firefox */</span><br><span class="line">-webkit-transform:rotate(7deg); /* Safari 和 Chrome */</span><br><span class="line">-o-transform:rotate(7deg); 	/* Opera */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-transition"><a href="#2-transition" class="headerlink" title="2 transition"></a>2 transition</h5><p><a href="https://www.w3school.com.cn/cssref/pr_transition.asp" target="_blank" rel="noopener">transition</a> 属性是一个简写属性，用于设置四个过渡属性：<br>· transition-property：规定设置过渡效果的 CSS 属性的名称。<br>· transition-duration：规定完成过渡效果需要多少秒或毫秒。<br>· transition-timing-function：规定速度效果的速度曲线。<br>· transition-delay：规定速度效果的速度曲线。</p>
]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>animate</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo常用命令</title>
    <url>/2020/08/09/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<blockquote>
<h3 id="Hexo常用的几个命令"><a href="#Hexo常用的几个命令" class="headerlink" title="Hexo常用的几个命令"></a>Hexo常用的几个命令</h3><h4 id="1-hexo-server"><a href="#1-hexo-server" class="headerlink" title="1. hexo server"></a>1. hexo server</h4><p><code>hexo server</code> ，可简写为 <code>hexo s</code>，启动本地服务器预览，默认地址为<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p>
<h4 id="2-hexo-new"><a href="#2-hexo-new" class="headerlink" title="2. hexo new"></a>2. hexo new</h4><p><code>hexo new</code> 创建一篇新的文章，后接文章名。</p>
<h4 id="3-hexo-generate"><a href="#3-hexo-generate" class="headerlink" title="3. hexo generate"></a>3. hexo generate</h4><p><code>hexo generate</code>，可简写为<code>hexo g</code>，生成静态文件。</p>
<h4 id="4-hexo-clean"><a href="#4-hexo-clean" class="headerlink" title="4. hexo clean"></a>4. hexo clean</h4><p><code>hexo clean</code> 清除缓存文件 (db.json) 和已生成的静态文件 (public)。</p>
<h4 id="5-hexo-deploy"><a href="#5-hexo-deploy" class="headerlink" title="5. hexo deploy"></a>5. hexo deploy</h4><p><code>hexo deploy</code> ，可简写为<code>hexo d</code>，文件生成后立即部署网站</p>
</blockquote>
<blockquote>
<p>详细可访问<a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">Hexo</a>官网查看更多命令。</p>
</blockquote>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次使用Markdown编辑器</title>
    <url>/2020/03/07/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8Markdown%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    <content><![CDATA[<h1 id="第一次使用Markdown编辑器"><a href="#第一次使用Markdown编辑器" class="headerlink" title="第一次使用Markdown编辑器"></a>第一次使用Markdown编辑器</h1><hr>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;studio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"c="</span>,a+b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//this is code area. </span></span><br><span class="line"><span class="comment">//男子高校生の日常</span></span><br><span class="line"><span class="comment">//男子高中生的日常</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">myList = &#123;&#125;</span><br><span class="line">fot i <span class="keyword">in</span> myList:</span><br><span class="line">print(i)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"#id"</span>).onclick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">$(<span class="string">"#name"</span>).val(<span class="string">'zyl'</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我的blog地址：<a href="https://www.zyl315.com" target="_blank" rel="noopener">https://www.zyl315.com</a></p>
<p><a href="http://www.zyl315.com" target="_blank" rel="noopener">blog</a></p>
<p>|  姓名  |年龄| 班级 |<br>|—-|–|–|–|<br>|  Jack  |  20  | 1601 |<br>|  Army  |  21  | 1602 |</p>
<h6 id="使用jsDelivr-GitHub-CND加速的图床例子"><a href="#使用jsDelivr-GitHub-CND加速的图床例子" class="headerlink" title="使用jsDelivr+GitHub CND加速的图床例子"></a>使用jsDelivr+GitHub CND加速的图床例子</h6><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zyl315/CDN/img/desk.jpg" title="例子" style="zoom:25%;" />

<img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/zyl315/CDN/img/(0).jpg.webp" style="zoom: 25%;" />



</blockquote>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>test_my_title</title>
    <url>/2020/03/06/test-my-title/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
